# api/index.py
import sys
import io
import asyncio
import json
import os
from contextlib import asynccontextmanager
from typing import Any, Dict, List, Optional, Literal

# === ÂºïÂÖ• PostgreSQL È©±Âä® ===
import psycopg2
from psycopg2 import extras # Áî®‰∫éÂ≠óÂÖ∏Ê∏∏Ê†á
import requests # Êñ∞Â¢ûÔºåÁî®‰∫éÂèëÈÄÅ Webhook

# === ÂºïÂÖ• FastMCP Ê°ÜÊû∂ ===
from fastmcp import FastMCP

# =================================================================
# Ê†∏ÂøÉ‰ºòÂåñ 1ÔºöÂº∫Âà∂‰ΩøÁî® UTF-8 ÁºñÁ†Å (‰∏ªË¶ÅÁî®‰∫éÊú¨Âú∞Ë∞ÉËØï)
# =================================================================
try:
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')
except Exception:
    pass

# =================================================================
# PostgreSQL ËøûÊé•ÈÖçÁΩÆ (‰ªéÁéØÂ¢ÉÂèòÈáèËØªÂèñ)
# =================================================================
POSTGRES_URL = os.getenv("POSTGRES_URL")

# Âº∫Âà∂Ê£ÄÊü•ÂÖ≥ÈîÆÁéØÂ¢ÉÂèòÈáèÊòØÂê¶ËÆæÁΩÆ
if not POSTGRES_URL:
    print("‚ùå ÈîôËØØ: Áº∫Â∞ëÂøÖË¶ÅÁöÑ POSTGRES_URL ÁéØÂ¢ÉÂèòÈáè„ÄÇËØ∑Â∞Ü Vercel Project ÈìæÊé•Âà∞ Vercel Postgres Êï∞ÊçÆÂ∫ì„ÄÇ")
    raise ValueError("Missing POSTGRES_URL environment variable. Please link a Vercel Postgres database.")

TABLE_SONGS = "songs"
TABLE_ARTISTS = "artists"

# =================================================================
# GitHub Actions Webhook ÈÖçÁΩÆ (Êñ∞Â¢û)
# =================================================================
# Ëøô‰∫õÂèòÈáèÈúÄË¶ÅÂú® Vercel È°πÁõÆÁöÑÁéØÂ¢ÉÂèòÈáè‰∏≠ËÆæÁΩÆ (‰Ωú‰∏∫ Secrets)
# GITHUB_REPO_OWNER: GitHub ‰ªìÂ∫ìÊâÄÊúâËÄÖ (‰æãÂ¶Ç: your-username)
# GITHUB_REPO_NAME: GitHub ‰ªìÂ∫ìÂêçÁß∞ (‰æãÂ¶Ç: your-music-library)
# GITHUB_PERSONAL_ACCESS_TOKEN: ÂÖ∑Êúâ 'repo' ÊùÉÈôêÁöÑ PATÔºåÁî®‰∫éËß¶Âèë GHA„ÄÇËØ∑Âä°ÂøÖ‰øùÂØÜÔºÅ
GITHUB_REPO_OWNER = os.getenv("GITHUB_REPO_OWNER")
GITHUB_REPO_NAME = os.getenv("GITHUB_REPO_NAME")
GITHUB_PERSONAL_ACCESS_TOKEN = os.getenv("GITHUB_PERSONAL_ACCESS_TOKEN")

# Â¶ÇÊûúÁº∫Â∞ëËøô‰∫õÂèòÈáèÔºåÊúçÂä°‰ªçÁÑ∂ÂèØ‰ª•ÂêØÂä®Ôºå‰ΩÜÊó†Ê≥ïËß¶Âèë GitHub Actions
if not all([GITHUB_REPO_OWNER, GITHUB_REPO_NAME, GITHUB_PERSONAL_ACCESS_TOKEN]):
    print("‚ö†Ô∏è Ë≠¶Âëä: Áº∫Â∞ë GitHub Actions Webhook ÂøÖË¶ÅÁöÑÁéØÂ¢ÉÂèòÈáè (GITHUB_REPO_OWNER, GITHUB_REPO_NAME, GITHUB_PERSONAL_ACCESS_TOKEN)„ÄÇ")
    print("           FastMCP ÊúçÂä°Â∞ÜÊó†Ê≥ïËá™Âä®Ëß¶Âèë GitHub Actions„ÄÇ")

# =================================================================
# Êï∞ÊçÆÂ∫ìËæÖÂä©Á±ª (psycopg2 ÂºÇÊ≠•ËøûÊé•ÂíåÊâπÈáèÊìç‰Ωú)
# =================================================================
class DatabaseManager:
    """ÁÆ°ÁêÜ PostgreSQL Êï∞ÊçÆÂ∫ìËøûÊé•ÂíåÊìç‰ΩúÁöÑÁ±ª„ÄÇ"""

    def __init__(self, dsn: str):
        self.dsn = dsn

    @asynccontextmanager
    async def get_connection(self):
        """Êèê‰æõ‰∏Ä‰∏™ÂºÇÊ≠•‰∏ä‰∏ãÊñáÁÆ°ÁêÜÂô®ÔºåÁî®‰∫éÊØèÊ¨°Êìç‰ΩúÊó∂Ëé∑ÂèñÂíåËá™Âä®ÂÖ≥Èó≠Êï∞ÊçÆÂ∫ìËøûÊé•„ÄÇ"""
        conn = None
        try:
            def _connect():
                nonlocal conn
                conn = psycopg2.connect(self.dsn)
                conn.autocommit = True
            await asyncio.to_thread(_connect)
            yield conn
        finally:
            if conn:
                def _close():
                    conn.close()
                await asyncio.to_thread(_close)

    async def execute_query(self, sql: str, params: tuple = ()) -> List[Dict[str, Any]]:
        """ÂºÇÊ≠•ÊâßË°åÊü•ËØ¢ (SELECT)„ÄÇ"""
        async with self.get_connection() as conn:
            def _execute():
                with conn.cursor(cursor_factory=extras.RealDictCursor) as cursor:
                    cursor.execute(sql, params)
                    results = cursor.fetchall()
                return results
            return await asyncio.to_thread(_execute)

    async def execute_non_query(self, sql: str, params: tuple = ()) -> int:
        """ÂºÇÊ≠•ÊâßË°åÈùûÊü•ËØ¢Êìç‰Ωú (INSERT, UPDATE, DELETE ÂçïÊù°)„ÄÇ"""
        async with self.get_connection() as conn:
            def _execute():
                with conn.cursor() as cursor:
                    cursor.execute(sql, params)
                return cursor.rowcount
            return await asyncio.to_thread(_execute)

    async def execute_many(self, sql: str, params_list: List[tuple]) -> int:
        """ÂºÇÊ≠•ÊâßË°åÊâπÈáèÈùûÊü•ËØ¢Êìç‰Ωú (INSERT MANY, DELETE MANY)„ÄÇ"""
        async with self.get_connection() as conn:
            def _execute():
                with conn.cursor() as cursor:
                    cursor.executemany(sql, params_list)
                return len(params_list) # psycopg2.executemany doesn't return total rows affected directly
            return await asyncio.to_thread(_execute)

db_manager = DatabaseManager(POSTGRES_URL)

# =================================================================
# MCP Lifespan (Êï∞ÊçÆÂ∫ìË°®ÂàõÂª∫ÂíåÂàùÂßãÂåñÊï∞ÊçÆ)
# =================================================================
async def create_tables_if_not_exist():
    """‰ΩøÁî® DatabaseManager ÂàõÂª∫ songs Âíå artists Ë°® (Â¶ÇÊûú‰∏çÂ≠òÂú®)„ÄÇ"""
    sql_artists = f"""
    CREATE TABLE IF NOT EXISTS "{TABLE_ARTISTS}" (
        artist_id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        genre VARCHAR(50),
        country VARCHAR(50)
    );
    """
    await db_manager.execute_non_query(sql_artists)

    sql_songs = f"""
    CREATE TABLE IF NOT EXISTS "{TABLE_SONGS}" (
        id SERIAL PRIMARY KEY,
        artist VARCHAR(255) NOT NULL,
        song_name VARCHAR(255) NOT NULL
    );
    """
    await db_manager.execute_non_query(sql_songs)

    try:
        await db_manager.execute_non_query(
            f"INSERT INTO \"{TABLE_ARTISTS}\" (name, genre, country) VALUES (%s, %s, %s) ON CONFLICT (name) DO NOTHING;",
            ("The Beatles", "Rock", "UK")
        )
    except Exception as e:
        print(f"‚ö†Ô∏è ÊèíÂÖ•ÂàùÂßãËâ∫ÊúØÂÆ∂Êï∞ÊçÆÂ§±Ë¥• (ÂèØËÉΩÂ∑≤Â≠òÂú®ÊàñÂèëÁîüÂÖ∂‰ªñÈîôËØØ): {e}")

@asynccontextmanager
async def lifespan(app):
    """FastMCP ÁöÑÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ„ÄÇÂú® Vercel ÊØèÊ¨°ÂÜ∑ÂêØÂä®ÊàñÈÉ®ÁΩ≤Êó∂‰ºöÊâßË°å„ÄÇ"""
    print(f"üîÑ Vercel function cold start/deployment: Checking/Creating PostgreSQL tables...")
    try:
        await create_tables_if_not_exist()
        print("‚úÖ Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÂíåÂàùÂßãÊï∞ÊçÆËÆæÁΩÆÂÆåÊàê„ÄÇ")
    except Exception as e:
        print(f"‚ùå Êï∞ÊçÆÂ∫ìËøûÊé•/ÂàùÂßãÂåñÂ§±Ë¥•: {type(e).__name__}: {e}")
        raise # ÊäõÂá∫ÂºÇÂ∏∏‰ª•ÈòªÊ≠¢‰∏çÂÅ•Â∫∑ÁöÑÈÉ®ÁΩ≤
    yield
    print("üëã Vercel function clean up (connections are per-request).")

# =================================================================
# ÂàùÂßãÂåñ FastMCP Â∫îÁî®
# =================================================================
mcp_app = FastMCP(
    name="Music Database Service (Vercel Postgres)",
    instructions="This service provides full CRUD access to the music database via optimized HTTP/JSON-RPC tools, deployed on Vercel with Vercel Postgres, and can trigger GitHub Actions on database changes.",
    lifespan=lifespan
)

# =================================================================
# GitHub Actions Webhook Ëß¶ÂèëÂáΩÊï∞ (Êñ∞Â¢û)
# =================================================================
def trigger_github_action_webhook(event_type: str, client_payload: Dict[str, Any]):
    """
    ÈÄöËøá GitHub Repository Dispatch Webhook Ëß¶Âèë GitHub Actions„ÄÇ
    https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#repository_dispatch
    """
    if not all([GITHUB_REPO_OWNER, GITHUB_REPO_NAME, GITHUB_PERSONAL_ACCESS_TOKEN]):
        print("‚ö†Ô∏è Êó†Ê≥ïËß¶Âèë GitHub Actions WebhookÔºåÁº∫Â∞ëÂøÖË¶ÅÁöÑÈÖçÁΩÆ (OWNER, NAME, PAT)„ÄÇ")
        return

    url = f"https://api.github.com/repos/{GITHUB_REPO_OWNER}/{GITHUB_REPO_NAME}/dispatches"
    headers = {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": f"token {GITHUB_PERSONAL_ACCESS_TOKEN}",
        "Content-Type": "application/json"
    }
    data = {
        "event_type": event_type,
        "client_payload": client_payload
    }

    try:
        print(f"üîÑ Ê≠£Âú®Â∞ùËØïËß¶Âèë GitHub Actions Webhook (event_type: {event_type})...")
        response = requests.post(url, headers=headers, json=data, timeout=10)
        response.raise_for_status()
        print(f"‚úÖ ÊàêÂäüËß¶Âèë GitHub Actions Webhook (event_type: {event_type})„ÄÇ")
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Ëß¶Âèë GitHub Actions Webhook Â§±Ë¥•: {e}")
    except Exception as e:
        print(f"‚ùå Ëß¶Âèë GitHub Actions Webhook Êó∂ÂèëÁîüÊÑèÂ§ñÈîôËØØ: {e}")

# =================================================================
# FastMCP Tools (‰øÆÊîπ CRUD Â∑•ÂÖ∑ÔºåÂú®ÊàêÂäü‰øÆÊîπÂêéËß¶Âèë Webhook)
# =================================================================

# --- 1. Êü• (Read) ---
@mcp_app.tool()
async def list_music_data(
        table_name: Literal["artists", "songs"],
        limit: int = 10,
        offset: int = 0,
        filter_conditions: Optional[Dict[str, Any]] = None,
) -> str:
    """‰ªéÊåáÂÆöÈü≥‰πêË°®‰∏≠Ê£ÄÁ¥¢Êï∞ÊçÆ (Êü•)„ÄÇ"""
    if limit > 100: limit = 100
    if table_name not in [TABLE_ARTISTS, TABLE_SONGS]:
        return json.dumps({"status": "error", "message": "Invalid table name specified."}, ensure_ascii=False)

    sql = f"SELECT * FROM \"{table_name}\""
    params = []
    if filter_conditions:
        where_clauses = []
        for key, value in filter_conditions.items():
            where_clauses.append(f"\"{key}\" ILIKE %s")
            params.append(f"%{value}%")
        sql += " WHERE " + " AND ".join(where_clauses)
    sql += " LIMIT %s OFFSET %s"
    params.extend([limit, offset])

    try:
        results = await db_manager.execute_query(sql, tuple(params))
        return json.dumps({
            "status": "success",
            "count": len(results),
            "data": results
        }, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå PostgreSQL query failed for list_music_data: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL query failed: {e}"}, ensure_ascii=False)


# --- 2. Â¢û (Create) - ÂçïÊù° ---
@mcp_app.tool()
async def add_song(
        song_name: str,
        artist: Optional[str] = None
) -> str:
    """Âêë 'songs' Ë°®‰∏≠Ê∑ªÂä†‰∏ÄÈ¶ñÊñ∞Ê≠åÊõ≤ (Â¢û)ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    final_artist = artist if artist is not None and artist.strip() else "Êú™Áü•Ê≠åÊâã"
    sql = f"INSERT INTO \"{TABLE_SONGS}\" (artist, song_name) VALUES (%s, %s)"
    params = (final_artist, song_name)
    try:
        row_count = await db_manager.execute_non_query(sql, params)
        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "add", "song_name": song_name, "artist": final_artist}
            )
            return json.dumps(
                {"status": "success", "message": f"Successfully added song: {song_name} by {final_artist}"},
                ensure_ascii=False)
        else:
            return json.dumps({"status": "error", "message": "Song not added."}, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå PostgreSQL insertion failed for add_song: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL insertion failed: {e}"}, ensure_ascii=False)


# --- 2. Â¢û (Create) - ÊâπÈáè ---
@mcp_app.tool()
async def batch_add_songs(
        songs_list: List[Dict[str, str]],
        default_artist: Optional[str] = None
) -> str:
    """Âêë 'songs' Ë°®‰∏≠ÊâπÈáèÊ∑ªÂä†Â§öÈ¶ñÊ≠åÊõ≤ (Â¢û)ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    if not songs_list:
        return json.dumps({"status": "warning", "message": "The songs_list is empty."}, ensure_ascii=False)

    params_list = []
    final_default_artist = default_artist if default_artist is not None and default_artist.strip() else "Êú™Áü•Ê≠åÊâã"

    for song in songs_list:
        song_name = song.get("song_name")
        artist = song.get("artist")
        if not song_name: continue
        final_artist = artist if artist is not None and artist.strip() else final_default_artist
        params_list.append((final_artist, song_name))

    if not params_list:
        return json.dumps({"status": "error", "message": "No valid songs found in the list."}, ensure_ascii=False)

    sql = f"INSERT INTO \"{TABLE_SONGS}\" (artist, song_name) VALUES (%s, %s)"

    try:
        row_count = await db_manager.execute_many(sql, params_list)
        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "batch_add", "count": row_count}
            )
        return json.dumps({
            "status": "success",
            "message": f"Successfully added approximately {row_count} songs.",
            "attempted_count": len(songs_list),
        }, ensure_ascii=False)

    except Exception as e:
        print(f"‚ùå PostgreSQL batch insertion failed for batch_add_songs: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL batch insertion failed: {e}"}, ensure_ascii=False)


# --- 3. Êîπ (Update) ---
@mcp_app.tool()
async def update_song(
        song_id: int,
        new_artist: Optional[str] = None,
        new_song_name: Optional[str] = None
) -> str:
    """Ê†πÊçÆÊ≠åÊõ≤ID‰øÆÊîπÊ≠åÊõ≤ÁöÑËâ∫ÊúØÂÆ∂ÊàñÂêçÁß∞ (Êîπ)ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    updates = []
    params = []

    if new_artist:
        updates.append("\"artist\" = %s")
        params.append(new_artist)
    if new_song_name:
        updates.append("\"song_name\" = %s")
        params.append(new_song_name)

    if not updates:
        return json.dumps({"status": "warning", "message": "No fields provided for update."}, ensure_ascii=False)

    sql = f"UPDATE \"{TABLE_SONGS}\" SET " + ", ".join(updates) + " WHERE \"id\" = %s"
    params.append(song_id)

    try:
        row_count = await db_manager.execute_non_query(sql, tuple(params))
        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "update", "song_id": song_id}
            )
            return json.dumps({"status": "success", "message": f"Successfully updated song with ID: {song_id}."},
                              ensure_ascii=False)
        else:
            return json.dumps({"status": "warning", "message": f"No song found with ID: {song_id}."},
                              ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå PostgreSQL update failed for update_song: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL update failed: {e}"}, ensure_ascii=False)


# --- 4. Âà† (Delete) - ÂçïÊù° ---
@mcp_app.tool()
async def delete_song(
        song_name: str,
        artist: Optional[str] = None
) -> str:
    """‰ªé 'songs' Ë°®‰∏≠Âà†Èô§‰∏ÄÈ¶ñÊåáÂÆöÂêçÁß∞ÁöÑÊ≠åÊõ≤ (Âà†)ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    sql = f"DELETE FROM \"{TABLE_SONGS}\" WHERE \"song_name\" = %s"
    params = [song_name]

    if artist:
        sql += " AND \"artist\" = %s"
        params.append(artist)

    try:
        row_count = await db_manager.execute_non_query(sql, tuple(params))
        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "delete", "song_name": song_name, "artist": artist, "count": row_count}
            )
            return json.dumps(
                {"status": "success", "message": f"Successfully deleted {row_count} song(s) named: {song_name}."},
                ensure_ascii=False)
        else:
            return json.dumps(
                {"status": "warning", "message": f"No song found named: {song_name} (or artist mismatch)."},
                ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå PostgreSQL deletion failed for delete_song: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL deletion failed: {e}"}, ensure_ascii=False)


# --- 4. Âà† (Delete) - ÊâπÈáè ---
@mcp_app.tool()
async def batch_delete_songs(
        songs_list: List[Dict[str, str]],
        default_artist: Optional[str] = None
) -> str:
    """‰ªé 'songs' Ë°®‰∏≠ÊâπÈáèÂà†Èô§Â§öÈ¶ñÊ≠åÊõ≤ (Âà†)ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    if not songs_list:
        return json.dumps({"status": "warning", "message": "The songs_list is empty."}, ensure_ascii=False)

    final_params_list = []
    final_default_artist = default_artist if default_artist is not None and default_artist.strip() else "Êú™Áü•Ê≠åÊâã"

    for song in songs_list:
        song_name = song.get("song_name")
        artist = song.get("artist")
        if not song_name: continue
        final_artist = artist if artist is not None and artist.strip() else final_default_artist
        final_params_list.append((song_name, final_artist))

    if not final_params_list:
        return json.dumps({"status": "error", "message": "No valid songs found in the list."}, ensure_ascii=False)

    sql = f"DELETE FROM \"{TABLE_SONGS}\" WHERE \"song_name\" = %s AND \"artist\" = %s"

    try:
        row_count = await db_manager.execute_many(sql, final_params_list)

        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "batch_delete", "count": row_count}
            )
            return json.dumps({
                "status": "success",
                "message": f"ÊàêÂäüÂà†Èô§Á∫¶ {row_count} È¶ñÊ≠åÊõ≤„ÄÇ",
                "deleted_count": row_count
            }, ensure_ascii=False)
        else:
            return json.dumps({
                "status": "warning",
                "message": f"Â∞ùËØïÂà†Èô§ {len(final_params_list)} È¶ñÊ≠åÊõ≤Ôºå‰ΩÜÊú™ÊâæÂà∞ÂåπÈÖçÈ°π (0 È¶ñÊ≠åÂà†Èô§ÊàêÂäü)„ÄÇËØ∑Ê£ÄÊü•Ê≠åÊâãÂêçÁß∞ÊòØÂê¶Ê≠£Á°Æ„ÄÇ",
                "deleted_count": 0
            }, ensure_ascii=False)

    except Exception as e:
        print(f"‚ùå PostgreSQL batch deletion failed for batch_delete_songs: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL batch deletion failed: {e}"}, ensure_ascii=False)


# --- 4. Âà† (Delete) - ÊåâÊ≠åÊâãÂà†Èô§ÊâÄÊúâÊ≠åÊõ≤ ---
@mcp_app.tool()
async def delete_songs_by_artist(
        artist: str
) -> str:
    """‰ªé 'songs' Ë°®‰∏≠Âà†Èô§Êüê‰ΩçÊ≠åÊâãÁöÑÊâÄÊúâÊ≠åÊõ≤ÔºåÊàêÂäüÂêéËß¶Âèë GitHub Actions„ÄÇ"""
    if not artist or not artist.strip():
        return json.dumps({"status": "error", "message": "Artist name is required."}, ensure_ascii=False)

    sql = f"DELETE FROM \"{TABLE_SONGS}\" WHERE \"artist\" = %s"
    params = (artist,)

    try:
        row_count = await db_manager.execute_non_query(sql, params)
        if row_count > 0:
            trigger_github_action_webhook(
                event_type="db_music_updated",
                client_payload={"action": "delete_by_artist", "artist": artist, "count": row_count}
            )
            return json.dumps({"status": "success", "message": f"ÊàêÂäüÂà†Èô§Ê≠åÊâã {artist} ÁöÑ {row_count} È¶ñÊ≠åÊõ≤„ÄÇ"},
                              ensure_ascii=False)
        else:
            return json.dumps({"status": "warning", "message": f"Êú™ÊâæÂà∞Ê≠åÊâã {artist} ÁöÑ‰ªª‰ΩïÊ≠åÊõ≤Ôºå0 È¶ñÊ≠åË¢´Âà†Èô§„ÄÇ"},
                              ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå PostgreSQL deletion failed for delete_songs_by_artist: {e}")
        return json.dumps({"status": "error", "message": f"PostgreSQL deletion failed: {e}"}, ensure_ascii=False)


# --- ËæÖÂä©Â∑•ÂÖ∑ (Êü•ÁªìÊûÑ) ---
@mcp_app.tool()
async def get_table_structure(
        table_name: Literal["artists", "songs"],
) -> str:
    """Ëé∑ÂèñÊåáÂÆöÈü≥‰πêË°®ÁöÑÂàóÁªìÊûÑÔºàÂêçÁß∞ÂíåÁ±ªÂûãÔºâ„ÄÇ"""
    if table_name not in [TABLE_ARTISTS, TABLE_SONGS]:
        return json.dumps({"status": "error", "message": "Invalid table name specified."}, ensure_ascii=False)

    sql = f"""
    SELECT column_name AS Field, udt_name AS Type, is_nullable AS Null
    FROM information_schema.columns
    WHERE table_name = %s AND table_schema = current_schema();
    """
    try:
        results = await db_manager.execute_query(sql, (table_name,))
        structure = [
            {"name": row['field'], "type": row['type'], "notnull": 1 if row['null'] == 'NO' else 0}
            for row in results
        ]

        return json.dumps({
            "status": "success",
            "table": table_name,
            "structure": structure
        }, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå Failed to get structure for {table_name}: {e}")
        return json.dumps({"status": "error", "message": f"Failed to get structure: {e}"}, ensure_ascii=False)

# =================================================================
# Vercel ÈúÄË¶ÅÁõ¥Êé•Êö¥Èú≤ ASGI Â∫îÁî®ÂØπË±°
# =================================================================
# mcp_app Â∑≤Âú®‰∏äÊñπÂÆö‰πâ